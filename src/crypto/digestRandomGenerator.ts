import CryptoJS from 'crypto-js';

function intToBytes(num: number): number[] {
    return [
        (num >> 24) & 0xff,
        (num >> 16) & 0xff,
        (num >> 8) & 0xff,
        num & 0xff
    ];
}

function wordArrayToBytes(wordArray: any): number[] {
    const words = wordArray.words;
    const bytes = [];
    for (let i = 0; i < words.length * 4; i++) {
        bytes.push((words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff);
    }
    return bytes;
}

export class DigestRandomGenerator {
    private static CYCLE_COUNT = 10;
    private stateCounter: number = 1;
    private seedCounter: number = 1;
    private state: number[];
    private seed: number[];

    constructor() {
        this.seed = new Array(64).fill(0);
        this.state = new Array(64).fill(0);
        // console.log('Initial seed:', Buffer.from(this.seed).toString('hex'));
        // console.log('Initial state:', Buffer.from(this.state).toString('hex'));
    }

    private digestAddCounter(counter: number): number[] {
        let value = counter;
        const bytes = [];
        for (let i = 0; i < 8; i++) {
            bytes.push(value & 0xff);
            value = value >>> 8;
        }
        return bytes;
    }

    private digest(data: number[]): number[] {
        const wordArray = CryptoJS.lib.WordArray.create(new Uint8Array(data));
        const hash = CryptoJS.SHA512(wordArray);
        return wordArrayToBytes(hash);
    }

    private cycleSeed(): void {
        // console.log('Cycling seed...');
        const counterBytes = this.digestAddCounter(this.seedCounter++);
        const input = [...this.seed, ...counterBytes];
        this.seed = this.digest(input);
        // console.log('New seed after cycle:', Buffer.from(this.seed).toString('hex'));
    }

    private generateState(): void {
        // console.log('\nGenerating state...');
        // console.log('Current state:', Buffer.from(this.state).toString('hex'));
        // console.log('Current seed:', Buffer.from(this.seed).toString('hex'));
        
        const counterBytes = this.digestAddCounter(this.stateCounter++);
        const input = [...counterBytes, ...this.state, ...this.seed];
        this.state = this.digest(input);
        
        if (this.stateCounter % DigestRandomGenerator.CYCLE_COUNT === 0) {
            this.cycleSeed();
        }
    }

    addSeedMaterial(seed: number[]): void {
        // console.log('\nAdding seed material:', Buffer.from(seed).toString('hex'));
        const input = [...seed, ...this.seed];
        this.seed = this.digest(input);
        // console.log('Seed after adding material:', Buffer.from(this.seed).toString('hex'));
    }

    nextBytes(length: number): number[] {
        // console.log('\nGenerating', length, 'bytes');
        const result = new Array(length);
        let index = 0;
        
        while (index < length) {
            this.generateState();
            const remaining = length - index;
            const copyLength = Math.min(this.state.length, remaining);
            for (let i = 0; i < copyLength; i++) {
                result[index + i] = this.state[i];
            }
            index += copyLength;
        }
        
        // console.log('Generated bytes:', Buffer.from(result).toString('hex'));
        return result;
    }
}